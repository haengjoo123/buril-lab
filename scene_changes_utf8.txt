commit 2e37f88646959e562cca4ed5c6198d4f0f12a7a2
Author: haengjoo123 <gudwns999999@gmail.com>
Date:   Fri Feb 20 21:49:20 2026 +0900

    feat: Implement initial fridge inventory management system with 3D visualization and Zustand state management.

diff --git a/src/features/fridge/FridgeScene.tsx b/src/features/fridge/FridgeScene.tsx
new file mode 100644
index 0000000..7ea75c3
--- /dev/null
+++ b/src/features/fridge/FridgeScene.tsx
@@ -0,0 +1,262 @@
+import React, { Suspense, useEffect, useMemo, useState } from 'react';
+import { Canvas, useThree } from '@react-three/fiber';
+import { OrbitControls, Environment, ContactShadows } from '@react-three/drei';
+import { useFridgeStore } from '../../store/fridgeStore';
+import { ShelfUnit } from './ShelfUnit';
+import { CabinetFrame } from './CabinetFrame';
+import { Divider } from './Divider';
+import { ResponsiveCamera } from './ResponsiveCamera';
+
+/** OrbitControls target媛 蹂寃쎈맆 ???숆린??(prop留뚯쑝濡쒕뒗 媛깆떊?????????덉쓬) */
+function SyncOrbitTarget({ target }: { target: [number, number, number] }) {
+    const { controls } = useThree();
+    useEffect(() => {
+        const orbit = controls as { target: { set: (x: number, y: number, z: number) => void }; update?: () => void } | null;
+        if (orbit?.target) orbit.target.set(...target);
+        if (typeof orbit?.update === 'function') orbit.update();
+    }, [controls, target]);
+    return null;
+}
+
+const REF_WIDTH = 10;
+const REF_HEIGHT = 2.75;
+/** CabinetFrame怨??숈씪 */
+const SHELF_BOTTOM_Y = -0.25;
+const CABINET_WALL = 0.12;
+/** ?곹븯 ?⑤꼸 ?먭퍡 (CabinetFrame WALL怨??숈씪) */
+const PANEL_THICKNESS = CABINET_WALL;
+/** ?좊컲 ?먭퍡 (ShelfUnit SHELF_HEIGHT? ?숈씪) */
+const SHELF_HEIGHT = 0.2;
+
+/** ?뺣㈃ ????30??媛곷룄 - ?쒖빟 諛곗튂 ??怨좎젙 ?쒖젏 */
+const PLACE_ELEVATION_DEG = 30; // ?섑룊??湲곗? ??30??+const PLACE_ELEVATION_RAD = PLACE_ELEVATION_DEG * (Math.PI / 180);
+
+/** PLACE 紐⑤뱶?먯꽌 ?寃??좊컲/諛붾떏) ?대┃ ??移대찓?쇰? ?뺣㈃ ?뺣젹 + 怨좎젙 媛곷룄濡?諛곗튂 */
+function getPlaceModeCameraForTarget(
+    target: [number, number, number],
+    cabinetWidth: number,
+    cabinetHeight: number
+) {
+    const sizeFactor = Math.max(cabinetWidth / REF_WIDTH, cabinetHeight / REF_HEIGHT);
+    const dist = 5 + sizeFactor * 1.2;
+    const xOffset = 0.4 * (cabinetWidth / REF_WIDTH); // ?뺣㈃??媛源앷쾶
+    const targetY = target[1];
+    // ?뺣㈃(異? ??30?? target?먯꽌 ??+Z) ??+Y) 諛⑺뼢?쇰줈 dist留뚰겮
+    const posY = targetY + dist * Math.sin(PLACE_ELEVATION_RAD);
+    const posZ = dist * Math.cos(PLACE_ELEVATION_RAD);
+    return {
+        position: [xOffset, posY, posZ] as [number, number, number],
+        target: [0, targetY, 0] as [number, number, number],
+    };
+}
+
+function useCabinetCamera(
+    cabinetWidth: number,
+    cabinetHeight: number,
+    mode: 'VIEW' | 'EDIT' | 'PLACE'
+) {
+    return useMemo(() => {
+        const sizeFactor = Math.max(cabinetWidth / REF_WIDTH, cabinetHeight / REF_HEIGHT);
+        const distance = 7 + sizeFactor * 1.8;
+        const minDistance = 4 + sizeFactor * 1.5;
+        const maxDistance = 8 + sizeFactor * 4;
+        const targetY = cabinetHeight * 0.35 - 0.75;
+        const target: [number, number, number] = [0, targetY, 0];
+
+        if (mode === 'PLACE') {
+            // 湲곕낯 ?寃잛쓣 ?꾨옒履?25%)?쇰줈 - 媛???꾨옒 移몄씠 蹂댁씠?꾨줉
+            const placeTargetY = cabinetHeight * 0.25 - 0.75;
+            const placeTarget: [number, number, number] = [0, placeTargetY, 0];
+            const place = getPlaceModeCameraForTarget(placeTarget, cabinetWidth, cabinetHeight);
+            return {
+                position: place.position,
+                minDistance,
+                maxDistance,
+                target: place.target,
+                isPlaceMode: true,
+            };
+        }
+
+        const xOffset = 2.8 * (cabinetWidth / REF_WIDTH);
+        const yOffset = targetY + 0.4;
+        const posZ = Math.sqrt(Math.max(1, distance * distance - xOffset * xOffset - (yOffset - targetY) ** 2));
+        return {
+            position: [xOffset, yOffset, posZ] as [number, number, number],
+            minDistance,
+            maxDistance,
+            target,
+            isPlaceMode: false,
+        };
+    }, [cabinetWidth, cabinetHeight, mode]);
+}
+
+export const FridgeScene: React.FC = () => {
+    const shelves = useFridgeStore((state) => state.shelves);
+    const mode = useFridgeStore((state) => state.mode);
+    const draggedItem = useFridgeStore((state) => state.draggedItem);
+    const setDraggedItem = useFridgeStore((state) => state.setDraggedItem);
+
+    useEffect(() => {
+        if (!draggedItem) return;
+        const onPointerUp = () => {
+            setDraggedItem(null);
+            document.body.style.cursor = 'default';
+        };
+        window.addEventListener('pointerup', onPointerUp);
+        return () => window.removeEventListener('pointerup', onPointerUp);
+    }, [draggedItem, setDraggedItem]);
+    const cabinetWidth = useFridgeStore((state) => state.cabinetWidth);
+    const cabinetHeight = useFridgeStore((state) => state.cabinetHeight);
+    const cabinetDepth = useFridgeStore((state) => state.cabinetDepth);
+
+    const floorShelf = useMemo(() => shelves.find(s => s.id === 'floor'), [shelves]);
+    const floatingShelves = useMemo(() => shelves.filter(s => s.id !== 'floor'), [shelves]);
+
+    /** ?곹븯 ?⑤꼸쨌?좊컲 ?먭퍡瑜?怨좊젮?섏뿬 N+1移?洹좊벑 遺꾪븷
+     *  innerBottom: ?섑뙋 ??泥?移?諛붾떏), innerTop: ?곹뙋 ?섎떒(?ㅼ젣 泥쒖옣)
+     */
+    const { getShelfY, cellHeight, innerBottom, innerTop } = useMemo(() => {
+        const count = floatingShelves.length;
+        const bottom = SHELF_BOTTOM_Y + PANEL_THICKNESS;
+        const top = SHELF_BOTTOM_Y + cabinetHeight; // ?곹뙋 ?섎떒 = ?ㅼ젣 泥쒖옣 (PANEL ?쒖쇅)
+        const usableHeight = top - bottom;
+        if (count === 0) return { getShelfY: () => 0, cellHeight: 0.6, innerBottom: bottom, innerTop: top };
+        const totalGap = usableHeight - count * SHELF_HEIGHT;
+        const gapHeight = totalGap / (count + 1);
+        const getY = (index: number) => bottom + (index + 1) * (gapHeight + SHELF_HEIGHT);
+        return { getShelfY: getY, cellHeight: gapHeight, innerBottom: bottom, innerTop: top };
+    }, [floatingShelves.length, cabinetHeight]);
+
+    const cameraConfig = useCabinetCamera(cabinetWidth, cabinetHeight, mode);
+    const [shelfFocusTarget, setShelfFocusTarget] = useState<[number, number, number] | null>(null);
+    const focusedShelfId = useFridgeStore((state) => state.focusedShelfId);
+    const setFocusedShelfId = useFridgeStore((state) => state.setFocusedShelfId);
+    const GROUP_OFFSET_Y = -0.5;
+
+    const effectiveTarget = shelfFocusTarget ?? cameraConfig.target;
+    const isPlaceMode = mode === 'PLACE';
+
+    /** ?좊컲/諛붾떏 ?대┃ ???대떦 ?寃?湲곗? ?뺣㈃ 30??移대찓??(VIEW/EDIT/PLACE 怨듯넻) */
+    const effectiveCameraConfig = useMemo(() => {
+        if (shelfFocusTarget != null) {
+            const place = getPlaceModeCameraForTarget(effectiveTarget, cabinetWidth, cabinetHeight);
+            return {
+                ...cameraConfig,
+                position: place.position,
+                target: place.target,
+            };
+        }
+        return { ...cameraConfig, target: effectiveTarget };
+    }, [shelfFocusTarget, effectiveTarget, cameraConfig, cabinetWidth, cabinetHeight]);
+
+    const handleShelfFocus = (shelfId: string, localY: number) => {
+        if (mode === 'PLACE' && focusedShelfId === shelfId) {
+            setShelfFocusTarget(null);
+            setFocusedShelfId(null);
+        } else {
+            setShelfFocusTarget([0, GROUP_OFFSET_Y + localY, 0]);
+            if (mode === 'PLACE') setFocusedShelfId(shelfId);
+        }
+    };
+
+    // For dividers, use any shelf available as reference since vertical panels are synced
+    const referenceShelf = floatingShelves[0] || floorShelf;
+
+    return (
+        <div className="w-full bg-gray-100 relative" style={{ height: 'calc(100dvh - 7rem)' }}>
+            <Canvas
+                shadows="soft"
+                camera={{ position: cameraConfig.position, fov: 52 }}
+                gl={{ preserveDrawingBuffer: true }}
+            >
+                <Suspense fallback={null}>
+                    <ResponsiveCamera
+                        cabinetWidth={cabinetWidth}
+                        cabinetHeight={cabinetHeight}
+                        config={effectiveCameraConfig}
+                    />
+                    <Environment preset="city" />
+                    <ambientLight intensity={0.5} />
+                    <spotLight position={[10, 10, 10]} angle={0.15} penumbra={1} shadow-mapSize={[512, 512]} castShadow />
+
+                    <group position={[0, -0.5, 0]}>
+                        <CabinetFrame
+                            width={cabinetWidth}
+                            depth={cabinetDepth}
+                            cabinetHeight={cabinetHeight}
+                            dimmed={isPlaceMode && focusedShelfId != null}
+                        />
+                        {/* 諛붾떏硫?(floor shelf) */}
+                        {floorShelf && (
+                            <ShelfUnit
+                                key={floorShelf.id}
+                                shelf={floorShelf}
+                                position={[0, SHELF_BOTTOM_Y + 0.02, 0]}
+                                shelfWidth={cabinetWidth}
+                                shelfDepth={cabinetDepth}
+                                cellHeight={cellHeight} // Use unified cellHeight or separate?
+                                onShelfFocus={(localY) => handleShelfFocus(floorShelf.id, localY)}
+                                shelfHeight={0.05}
+                                isDimmed={isPlaceMode && focusedShelfId != null && floorShelf.id !== focusedShelfId}
+                            />
+                        )}
+                        {/* 媛???꾨옒 移??섑뙋 ??泥??좊컲 ?섎떒) 援щ텇留?*/}
+                        {referenceShelf && referenceShelf.dividers.map((pos, index) => (
+                            <group key={`bottom-div-${index}`} position={[0, innerBottom, 0]}>
+                                <Divider
+                                    position={pos}
+                                    shelfWidth={cabinetWidth}
+                                    shelfDepth={cabinetDepth}
+                                    height={cellHeight}
+                                    dimmed={isPlaceMode && focusedShelfId != null}
+                                />
+                            </group>
+                        ))}
+
+                        {/* ?꾩썙吏??좊컲??*/}
+                        {floatingShelves.map((shelf, index) => (
+                            <ShelfUnit
+                                key={shelf.id}
+                                shelf={shelf}
+                                position={[0, getShelfY(index), 0]}
+                                shelfWidth={cabinetWidth}
+                                shelfDepth={cabinetDepth}
+                                cellHeight={cellHeight}
+                                onShelfFocus={(localY) => handleShelfFocus(shelf.id, localY)}
+                                isDimmed={isPlaceMode && focusedShelfId != null && shelf.id !== focusedShelfId}
+                            />
+                        ))}
+
+                        {/* 媛????移?留덉?留??좊컲 ?곷떒~?곹뙋 ?꾨옒) 援щ텇留?*/}
+                        {referenceShelf && referenceShelf.dividers.map((pos, index) => (
+                            <group key={`top-div-${index}`} position={[0, getShelfY(floatingShelves.length - 1), 0]}>
+                                <Divider
+                                    position={pos}
+                                    shelfWidth={cabinetWidth}
+                                    shelfDepth={cabinetDepth}
+                                    height={cellHeight}
+                                    dimmed={isPlaceMode && focusedShelfId != null}
+                                />
+                            </group>
+                        ))}
+                    </group>
+
+                    <ContactShadows position={[0, -1, 0]} opacity={0.4} scale={10} blur={2.5} far={4} />
+                    <OrbitControls
+                        makeDefault
+                        minPolarAngle={Math.PI / 6}
+                        maxPolarAngle={Math.PI / 2}
+                        minDistance={cameraConfig.minDistance}
+                        maxDistance={cameraConfig.maxDistance}
+                        target={effectiveTarget}
+                        enableRotate={!isPlaceMode}
+                        enablePan={!isPlaceMode}
+                        enableZoom={true}
+                    />
+                    <SyncOrbitTarget target={effectiveTarget} />
+                </Suspense>
+            </Canvas>
+        </div>
+    );
+};
